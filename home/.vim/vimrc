" Prelude {{{
if has('vim_starting')
  " Use defaults.vim
  source $VIMRUNTIME/defaults.vim
  " Sets the character encoding inside Vim.
  set encoding=utf-8
  scriptencoding utf-8
endif
" }}}

" Revert defaults.vim {{{
" The following options are configured in default.vim
if has('vim_starting')
  set history=10000     " increate n of command line history
endif
set noruler             " [slow] do not show the cursor position.

" Do not highlight string inside C comments.
unlet c_comment_strings
" }}}

" Disable unnecessary features {{{
set belloff=all
set noerrorbells
set novisualbell t_vb=

" disable unnecessary default plugins
let g:loaded_gzip              = 1
let g:loaded_tar               = 1
let g:loaded_tarPlugin         = 1
let g:loaded_zip               = 1
let g:loaded_zipPlugin         = 1
let g:loaded_rrhelper          = 1
let g:loaded_2html_plugin      = 1
let g:loaded_vimball           = 1
let g:loaded_vimballPlugin     = 1
let g:loaded_getscript         = 1
let g:loaded_getscriptPlugin   = 1
let g:loaded_netrw             = 1
let g:loaded_netrwPlugin       = 1
let g:loaded_netrwSettings     = 1
let g:loaded_netrwFileHandlers = 1
let g:loaded_logipat           = 1
let g:loaded_matchparen        = 1
let g:loaded_man               = 1
" }}}

" Environmental configure {{{
set shell=/bin/bash
let $MYVIM_HOME   = expand('~/.vim')
let $MYVIM_DATA   = expand('~/Dropbox/Apps/Vim')
let $MYVIM_VIMRC  = resolve(expand('$MYVIM_HOME/vimrc'))
let $MYVIM_GVIMRC = resolve(expand('$MYVIM_HOME/gvimrc'))

" Add several required path to $PATH
call vimrc#prepend_envpath('$PATH', [
      \ '/usr/local/bin',
      \ '/usr/local/texlive/2013/bin/x86_64-linux',
      \ '/usr/local/texlive/2013/bin/x86_64-darwin',
      \ '~/.pyenv/bin',
      \ '~/.plenv/bin',
      \ '~/.rbenv/bin',
      \ '~/.ndenv/bin',
      \ '~/.pyenv/shims',
      \ '~/.plenv/shims',
      \ '~/.rbenv/shims',
      \ '~/.ndenv/shims',
      \ '~/.anyenv/envs/pyenv/bin',
      \ '~/.anyenv/envs/plenv/bin',
      \ '~/.anyenv/envs/rbenv/bin',
      \ '~/.anyenv/envs/ndenv/bin',
      \ '~/.anyenv/envs/pyenv/shims',
      \ '~/.anyenv/envs/plenv/shims',
      \ '~/.anyenv/envs/rbenv/shims',
      \ '~/.anyenv/envs/ndenv/shims',
      \ '~/.cabal/bin',
      \ '$MYVIM_HOME/bundle/repos/github.com/thinca/vim-themis/bin',
      \ '$MYVIM_HOME/bundle/repos/github.com/syngan/vim-vimlint/bin',
      \ '$MYVIM_HOME/bundle/repos/github.com/Kuniwak/vint/bin',
      \])
call vimrc#prepend_envpath('$MANPATH', [
      \ '/usr/local/share/man/',
      \])
let $PYENV_ROOT = vimrc#pick_path([
      \ '~/.anyenv/envs/pyenv',
      \ '~/.pyenv',
      \])
set viewdir=$MYVIM_HOME/.view
set undodir=$MYVIM_HOME/.undo
set spellfile=$MYVIM_DATA/system/spellfile.utf-8.add
call vimrc#ensure_path(&viewdir)
call vimrc#ensure_path(&undodir)
call vimrc#ensure_path(fnamemodify(&spellfile, ':p:h'))

if has('gui_running') || has('nvim')
  set timeout timeoutlen=1000 ttimeoutlen=100
else
  set t_Co=256     " use 256 colors
  set ttyfast      " enable fast terminal connection
  set ttyscroll=3  " the maximum number of lines for scrolling.
                         " use small value here to prefer redraw the screen
                         " instead of scrolling
  set notimeout ttimeout ttimeoutlen=100
endif

" }}}

" Language {{{

" prefer English interface
language message C

" prefer English help
set helplang=en,ja

" set default language for spell check
" cjk - ignore spell check on Asian characters (China, Japan, Korea)
set nospell
set spelllang=en_us,cjk
set fileencodings=ucs-bom,utf-8,euc-jp,iso-2022-jp,cp932,utf-16,utf-16le
set fileformats=unix,dos,mac
" }}}

" Interface {{{
set hidden              " hide the buffer instead of close
set switchbuf=useopen   " use an existing buffer instaed of creating a new one

set showmatch           " highlight a partner of cursor character
set matchtime=1         " highlight a partner ASAP
set updatetime=500      " increase speed of CursorHold autocommand
set nostartofline       " let C-D, C-U,... to keep same column
set smartcase           " override the ignorecase if the search pattern contains
                        " upper case characters
set hlsearch            " highlight found terms

set foldlevelstart=99
set foldnestmax=3       " maximum fold nesting level
set foldcolumn=3        " show fold guide


set laststatus=2        " always shows statusline
set showtabline=2       " always shows tabline
set report=0            " reports any changes
set cmdheight=2
set lazyredraw          " do not redraw while command execution

set splitright          " vsplit to right

set sessionoptions-=options

" https://ddrscott.github.io/blog/2016/sidescroll/
set sidescroll=1

" vertically split buffers for vimdiff
set diffopt& diffopt+=vertical

" move cursor previous/next line when the cursor is first/last character in the
" line and user move the cursor left/right
set whichwrap=b,s,<,>,~,[,]

" store cursor, folds, slash, and unix on view
set viewoptions=cursor,folds,slash,unix

" use rich completion system in command line
set wildmode=list:longest,full
set wildoptions=tagfile


set list          " show invisible characters
if $LANG !=# 'C'
  set listchars=tab:»-,trail:-,extends:»,precedes:«,nbsp:%
else
  set listchars=tab:>-,trail:-,extends:>,precedes:<,nbsp:%
endif

" }}}

" Editing {{{
set smarttab        " insert blanks according to shiftwidth
set expandtab       " use spaces instead of TAB
set softtabstop=-1  " the number of spaces that a TAB counts for
set shiftwidth=2    " the number of spaces of an indent
set shiftround      " round indent to multiple of shiftwidth with > and <

set autoindent      " copy indent from current line when starting a new line
set copyindent      " copy the structure of the existing lines indent when
                    " autoindenting a new line
set preserveindent  " Use :retab to clean up whitespace

set undofile        " keep undo history on undofile
set virtualedit=all " allow virtual editing in all modes

" Remove a comment leader when joining lines (j)
set formatoptions& formatoptions+=j

" use clipboard register
" - unnamed     : 'selection' in X11; clipboard in Mac OS X and Windows
" - unnamedplus : 'clipboard' in X11, Mac OS X, and Windows (but yank)
set clipboard=unnamed,unnamedplus
if has('win32') || has('win64') || has('mac')
  set clipboard-=unnamedplus
endif

" completion settings
set complete& complete-=i,d
set completeopt&
set completeopt-=preview
set completeopt+=menu,longest,noselect
set pumheight=20        " height of popup menu
set showfulltag         " show both the tag name and the search pattern

" K to search the help with the cursor word
set keywordprg=:help
" every wrapped line will continue visually indented
set breakindent
set showbreak=\ +
" }}}

" Mapping {{{
" define <Leader> and <LocalLeader>
let mapleader = ';'
let maplocalleader = ','

" remove any existing keymap for leader and localleader
noremap <Leader>      <Nop>
noremap <LocalLeader> <Nop>

" disable dengerous mappings (ZZ: save and close, ZQ close)
noremap <MiddleMouse>   <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>


" Improve cursor operation
nnoremap <silent><expr> j  v:count == 0 ? 'gj' : 'j'
nnoremap <silent><expr> k  v:count == 0 ? 'gk' : 'k'
nnoremap <silent><expr> gj v:count == 0 ? 'j' : 'gj'
nnoremap <silent><expr> gk v:count == 0 ? 'k' : 'gk'


" <Home> goes to the beginning of the text on first press and the
" beginning of the line on second.
noremap <silent><expr> <Home>
      \ virtcol('.') - 1 <= indent('.') && col('.') > 1 ? '0' : '_'

" Clear the highlight with <C-l>
nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>

" Emacs like binding in Insert mode
inoremap <C-a> <Home>
inoremap <C-e> <End>
inoremap <C-f> <C-o>w
inoremap <C-b> <C-o>b
inoremap <C-d> <C-o>x

" Y to yank the end of line
nnoremap Y y$

" vv to select the line, like yy, dd
nnoremap vv 0v$

" Better <C-n>/<C-p> in command mode
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <Up>   <C-p>
cnoremap <Down> <C-n>

" simple window resize navigation
nnoremap <S-Left>  <C-w><<CR>
nnoremap <S-Right> <C-w>><CR>
nnoremap <S-Up>    <C-w>-<CR>
nnoremap <S-Down>  <C-w>+<CR>

" tag navigation
nnoremap <silent> [t  :<C-u>tprevious<CR>
nnoremap <silent> ]t  :<C-u>tnext<CR>
nnoremap <silent> g[t :<C-u>tfirst<CR>
nnoremap <silent> g]t :<C-u>tlast<CR>

" quickfix navigation
nnoremap <silent> [q  :<C-u>cprevious<CR>
nnoremap <silent> ]q  :<C-u>cnext<CR>
nnoremap <silent> g[q :<C-u>cfirst<CR>
nnoremap <silent> g]q :<C-u>clast<CR>
nnoremap <silent> [l  :<C-u>lprevious<CR>
nnoremap <silent> ]l  :<C-u>lnext<CR>
nnoremap <silent> g[l :<C-u>lfirst<CR>
nnoremap <silent> g]l :<C-u>llast<CR>

" file navigation
nnoremap <silent> {f  :<C-u>previous<CR>
nnoremap <silent> }f  :<C-u>next<CR>
nnoremap <silent> g{f :<C-u>first<CR>
nnoremap <silent> g}f :<C-u>last<CR>

" tab operation (make similar mapping with window operation)
" ref.
nnoremap <silent> <C-t>t     :<C-u>tabnew<CR>
nnoremap <silent> <C-t><C-t> :<C-u>tabnew<CR>
nnoremap <silent> <C-n> :<C-u>tabnext<CR>
nnoremap <silent> <C-p> :<C-u>tabprevious<CR>

" switch options
nnoremap <Plug>(my-switch) <Nop>
nmap <Leader>s <Plug>(my-switch)
nnoremap <silent> <Plug>(my-switch)s :<C-u>setl spell! spell?<CR>
nnoremap <silent> <Plug>(my-switch)l :<C-u>setl list! list?<CR>
nnoremap <silent> <Plug>(my-switch)t :<C-u>setl expandtab! expandtab?<CR>
nnoremap <silent> <Plug>(my-switch)w :<C-u>setl wrap! wrap?<CR>
nnoremap <silent> <Plug>(my-switch)p :<C-u>setl paste! paste?<CR>
nnoremap <silent> <Plug>(my-switch)b :<C-u>setl scrollbind! scrollbind?<CR>
nnoremap <silent> <Plug>(my-switch)y :<C-u>call <SID>toggle_syntax()<CR>
function! s:toggle_syntax() abort
  if exists('g:syntax_on')
    syntax off
    redraw
    echo 'syntax off'
  else
    syntax on
    redraw
    echo 'syntax on'
  endif
endfunction

" alias for :e ++enc= | :e ++ff=
cnoreabbrev ++u ++enc=utf8
cnoreabbrev ++s ++enc=cp932
cnoreabbrev ++e ++enc=euc-jp
cnoreabbrev ++x ++ff=unix
cnoreabbrev ++d ++ff=dos
cnoreabbrev ++m ++ff=mac

" I often mis-type...
nnoremap cie <Nop>
nnoremap cae <Nop>
nnoremap die <Nop>
nnoremap dae <Nop>
nnoremap yie <Nop>
nnoremap yae <Nop>

" }}}

" Macro {{{
augroup MyAutoCmd
  autocmd!
augroup END

" Automatically open a file in readonly mode when a corresponding swap file
" exists
autocmd MyAutoCmd SwapExists * let v:swapchoice = 'o'


" Automatically move cursor at eol when paste
if &virtualedit =~# '\<all\>'
  " http://vim-jp.org/vim-users-jp/2011/01/16/Hack-195.html
  nnoremap <silent><expr> p
        \ (col('.') >= col('$') ? '$' : '') . 'p'
endif


" Improve mkview/loadview {{{
function! s:checkview() abort
  if !&buflisted || &buftype =~# '^\%(nofile\|help\|quickfix\|terminal\)$'
    return 0
  endif
  return 1
endfunction
autocmd MyAutoCmd BufWinLeave * if s:checkview() | silent! mkview   | endif
autocmd MyAutoCmd BufWinEnter * if s:checkview() | silent! loadview | endif
" }}}

" Seemless substitution {{{
cnoreabbrev <silent><expr>s getcmdtype() ==# ':' && getcmdline() =~# '^s'
      \ ? "<C-u>%s/<C-r>=get([], getchar(0), '')<CR>"
      \ : 's'
cnoreabbrev <silent><expr>'<,'>s getcmdtype() ==# ':' && getcmdline() =~# "^'<,'>s"
      \ ? "'<,'>s/<C-r>=get([], getchar(0), '')<CR>"
      \ : "'<,'>s"
" }}}

" Reload vimrc with <Leader><Leader>r {{{
if !exists('*s:reload_vimrc')
  function! s:reload_vimrc() abort
    call vimrc#source_path($MYVIM_VIMRC)
    if has('gui_running')
      call vimrc#source_path($MYVIM_GVIMRC)
      redraw | echo printf('"%s" and "%s" has sourced (%s).',
            \ fnamemodify($MYVIM_VIMRC, ':t'),
            \ fnamemodify($MYVIM_GVIMRC, ':t'),
            \ strftime('%c')
            \)
    else
      redraw | echo printf('"%s" has sourced (%s).',
            \ fnamemodify($MYVIM_VIMRC, ':t'),
            \ strftime('%c')
            \)
    endif
  endfunction
endif
nnoremap <silent> <Plug>(my-reload-vimrc)
      \ :<C-u>call <SID>reload_vimrc()<CR>
nmap <F4> <Plug>(my-reload-vimrc)
" }}}

" source/reload current vimscript file " {{{
if !exists('*s:source_current_path')
  function! s:source_current_path() abort
    let abspath = resolve(expand('%:p'))
    if &filetype !=# 'vim'
      redraw
      echohl WarningMsg
      echo printf(
            \ 'The filetype of the current buffer is "%s" but it must be "vim" for source.',
            \ &filetype,
            \)
      echohl None
      return
    endif
    call vimrc#source_path(expand('%'), 0)
    redraw | echo printf('"%s" has sourced (%s).', expand('%:t'), strftime('%c'))
  endfunction
endif
nmap <silent> <Plug>(my-source) :<C-u>call <SID>source_current_path()<CR>
nmap <F5> <Plug>(my-source)
" }}}

" automatically create missing directories {{{
function! s:makedirs(dir, force) abort
  if a:dir =~# '^.\{-}://'
      " Non local file, ignore
      return
  endif
  if !isdirectory(a:dir)
    if a:force || input(printf('"%s" does not exist. Create? [y/N]', a:dir)) =~? '^y\%[es]$'
      call mkdir(a:dir, 'p')
    endif
  endif
endfunction
autocmd MyAutoCmd BufWritePre * call s:makedirs(expand('<afile>:p:h'), v:cmdbang)
" }}}

" Show runtimepath {{{
function! s:echo_runtimepath() abort
  for path in split(&runtimepath, ',')
    echo path
  endfor
endfunction
command! EchoRuntimePath call s:echo_runtimepath()
" }}}

" automatically change working directory on vim enter {{{
function! s:workon(dir, bang) abort
  let dir = (a:dir ==# '' ? expand('%') : a:dir)
  " convert filename to directory if required
  if filereadable(dir)
    let dir = fnamemodify(expand(dir),':p:h')
  else
    let dir = fnamemodify(dir, ':p')
  endif
  " change directory to specified directory
  if isdirectory(dir)
    silent execute 'cd ' . fnameescape(dir)
    if a:bang ==# ''
      redraw | echo 'Working on: '.dir
      if v:version > 703 || (v:version == 703 && has('patch438'))
        doautocmd <nomodeline> MyAutoCmd User my-workon-post
      else
        doautocmd MyAutoCmd User my-workon-post
      endif
    endif
  endif
endfunction
autocmd MyAutoCmd VimEnter * call s:workon(expand('<afile>'), 1)
command! -nargs=? -complete=dir -bang Workon call s:workon('<args>', '<bang>')
" }}}

" toggle quickfix window {{{
function! s:toggle_qf() abort
  let nwin = winnr('$')
  cclose
  if nwin == winnr('$')
    cwindow
  endif
endfunction
nnoremap <silent> <Leader>q :call <SID>toggle_qf()<CR>
" }}}

" Automatically re-assign filetype {{{
autocmd MyAutoCmd BufWritePost *
      \ if &filetype ==# '' || exists('b:ftdetect') |
      \  unlet! b:ftdetect |
      \  filetype detect |
      \ endif
"}}}

" Profiling a command {{{
function! s:timeit(q_args) abort
  let q_args = a:q_args
  let q_args = substitute(q_args, '^[\t :]\+', '', '')
  let q_args = substitute(q_args, '\s\+$', '', '')
  let args = substitute(q_args, '^[ :]*!', '', '')
  let start = reltime()
  try
    if q_args !=# '' && q_args[0] ==# '!'
      echo system(args)
    else
      execute q_args
    endif
  finally
    echomsg printf('Timeit: %s s [%s]', reltimestr(reltime(start)), a:q_args)
  endtry
endfunction
command! -nargs=+ -bang -complete=command Timeit call s:timeit(<q-args>)
" }}}

" Clear messages {{{
function! s:message_clear() abort
  for i in range(201)
    echomsg ''
  endfor
endfunction
command! -nargs=0 MessageClear call s:message_clear()
" }}}

" Better macro {{{
function! s:execute_macro_over_visual_range() abort
  execute ":'<,'>normal @" . nr2char(getchar())
endfunction
xnoremap <silent> <Plug>(my-execute-macro)
      \ :<C-u>call <SID>execute_macro_over_visual_range()<CR>
xmap @ <Plug>(my-execute-macro)
" }}}

" Add runtimepath {{{
function! s:add_runtimepath() abort
  let path = getcwd()
  execute printf('set runtimepath^=%s', fnameescape(path))
  if isdirectory(path . '/plugin')
    for filename in glob(path . '/plugin/*.vim', 0, 1)
      execute printf('source %s', fnameescape(filename))
    endfor
  endif
  echo printf('"%s" is added to &runtimepath', path)
endfunction
command! AddRuntimePath call s:add_runtimepath()
" }}}

function! s:switch_colorscheme() abort
  set background=dark
  if get(g:, 'colors_name', '') ==# 'hybrid'
    colorscheme iceberg
  else
    colorscheme hybrid
  endif
  redraw | echo g:colors_name
endfunction
nnoremap <silent><F3> :<C-u>call <SID>switch_colorscheme()<CR>

" }}}

call vimrc#source_path('$MYVIM_HOME/rc/dein.vim')

filetype indent plugin on
syntax on
try
  colorscheme iceberg
catch
  colorscheme desert
endtry

call vimrc#source_path('~/.vimrc.local')
set secure
" vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker
